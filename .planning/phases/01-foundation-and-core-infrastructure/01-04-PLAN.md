---
phase: 01-foundation-and-core-infrastructure
plan: 04
type: execute
wave: 3
depends_on:
  - "01-01"
  - "01-02"
  - "01-03"
files_modified:
  - src/ingot/agents/__init__.py
  - src/ingot/agents/base.py
  - src/ingot/agents/registry.py
  - src/ingot/agents/orchestrator.py
  - src/ingot/http_client.py
  - src/ingot/dispatcher.py
autonomous: true
requirements:
  - INFRA-17
  - INFRA-18
  - INFRA-19
  - INFRA-20
  - AGENT-01
  - AGENT-02
  - AGENT-03
  - AGENT-05
  - AGENT-06
  - AGENT-07
  - AGENT-08
  - AGENT-09

must_haves:
  truths:
    - "All 7 agent shells (Orchestrator, Scout, Research, Matcher, Writer, Outreach, Analyst) are importable"
    - "Each agent uses PydanticAI v1.x Agent with deps_type=AgentDeps — no v0.x result_type= parameter"
    - "AgentDeps dataclass carries llm_client, session, http_client — injected, never global"
    - "No agent file imports from any other agent file — Orchestrator is the only coordinator"
    - "Orchestrator is under 250 lines of Python"
    - "asyncio.Queue task dispatcher routes tasks to worker coroutines and runs them concurrently"
    - "Shared httpx.AsyncClient has connection pooling configured and is created once, not per-request"
    - "aiosmtplib and aioimaplib are imported as stubs (Phase 3 wiring) without error"
  artifacts:
    - path: "src/ingot/agents/base.py"
      provides: "AgentDeps dataclass and AgentBase protocol"
      exports: ["AgentDeps", "AgentBase"]
    - path: "src/ingot/agents/registry.py"
      provides: "AGENT_REGISTRY dict and register/get functions"
      exports: ["AGENT_REGISTRY", "register_agent", "get_agent"]
    - path: "src/ingot/agents/orchestrator.py"
      provides: "Orchestrator agent shell — under 250 lines, coordinates other agents via registry"
      exports: ["orchestrator_agent"]
    - path: "src/ingot/http_client.py"
      provides: "Shared httpx.AsyncClient singleton with connection pooling and request delay support"
      exports: ["get_http_client", "HttpClientConfig"]
    - path: "src/ingot/dispatcher.py"
      provides: "AsyncTaskDispatcher using asyncio.Queue with configurable worker pool"
      exports: ["AsyncTaskDispatcher", "TaskResult"]
  key_links:
    - from: "src/ingot/agents/orchestrator.py"
      to: "src/ingot/agents/registry.py"
      via: "AGENT_REGISTRY lookup — orchestrator routes tasks by agent name string"
      pattern: "AGENT_REGISTRY|get_agent"
    - from: "src/ingot/agents/base.py"
      to: "src/ingot/llm/client.py"
      via: "AgentDeps.llm_client: LLMClient — injected at call time from config"
      pattern: "LLMClient"
    - from: "src/ingot/dispatcher.py"
      to: "asyncio.Queue"
      via: "AsyncTaskDispatcher wraps asyncio.Queue — Redis upgrade path is isolated here"
      pattern: "asyncio\\.Queue"
---

<objective>
Wire the agent framework layer: PydanticAI agent shells for all 7 agents, shared HTTP client, async task dispatcher, and the Orchestrator skeleton.

Purpose: Phase 2 agents (Scout, Research, Matcher, Writer) need this framework to exist. Without the deps injection pattern, tests would require global state. Without the registry, Orchestrator would hardcode agent names.
Output: All 7 importable agent shells with correct PydanticAI v1.x API, shared resources, and task dispatcher.
</objective>

<execution_context>
@/Users/ishansingh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ishansingh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@.planning/phases/01-foundation-and-core-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-and-core-infrastructure/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: AgentDeps, AgentBase, registry, and shared resources</name>
  <files>
    src/ingot/agents/base.py
    src/ingot/agents/registry.py
    src/ingot/http_client.py
    src/ingot/dispatcher.py
  </files>
  <action>
**CRITICAL: Verify PydanticAI v1.x API before writing any agent code.** The RESEARCH.md flags that v0.x used `result_type=` but v1.x changed this (open question #1). Check the installed version:
```bash
python -c "import pydantic_ai; print(pydantic_ai.__version__)"
```
Then check the actual `Agent` constructor signature:
```bash
python -c "import inspect, pydantic_ai; print(inspect.signature(pydantic_ai.Agent.__init__))"
```
Use whatever parameter name the installed version actually uses. Document the finding in the output summary.

**src/ingot/agents/base.py:**

```python
"""
Agent dependency injection types.

All agents receive resources via AgentDeps — never via global state.
This makes agents testable (inject mocks) and independently deployable.
"""
from dataclasses import dataclass, field
from typing import Protocol, runtime_checkable
import httpx
from sqlalchemy.ext.asyncio import AsyncSession
from ingot.llm.client import LLMClient


@dataclass
class AgentDeps:
    """
    Dependency container injected into every agent via PydanticAI's deps_type.
    Construct once per agent invocation; do not share across concurrent runs.
    """
    llm_client: LLMClient
    session: AsyncSession
    http_client: httpx.AsyncClient
    verbosity: int = 0           # 0=normal, 1=-v, 2=-vv
    agent_name: str = ""         # Set by Orchestrator before dispatch


@runtime_checkable
class AgentBase(Protocol):
    """
    Protocol that all 7 agent modules must satisfy.
    Not enforced at runtime (duck typing), but documents the contract.
    """
    async def run(self, deps: AgentDeps, **kwargs) -> dict: ...
```

**src/ingot/agents/registry.py:**

```python
"""
Agent registry — simple dict[str, AgentBase].
In v2, this becomes dynamic discovery. In v1, agents are registered explicitly.
"""
from typing import Any

AGENT_REGISTRY: dict[str, Any] = {}

def register_agent(name: str, agent) -> None:
    """Register an agent by name. Called from each agent module's __init__."""
    AGENT_REGISTRY[name] = agent

def get_agent(name: str):
    """Retrieve agent by name. Raises KeyError if not registered."""
    if name not in AGENT_REGISTRY:
        registered = list(AGENT_REGISTRY.keys())
        raise KeyError(f"Agent '{name}' not in registry. Registered: {registered}")
    return AGENT_REGISTRY[name]

def list_agents() -> list[str]:
    return list(AGENT_REGISTRY.keys())
```

**src/ingot/http_client.py:**

```python
"""
Shared async HTTP client with connection pooling.
All agents use this — never create httpx.AsyncClient() inline.
"""
import asyncio
import httpx
from dataclasses import dataclass

@dataclass
class HttpClientConfig:
    max_keepalive_connections: int = 5
    max_connections: int = 10
    timeout_seconds: float = 30.0
    request_delay_seconds: float = 1.0  # Polite scraping delay

_client: httpx.AsyncClient | None = None
_config: HttpClientConfig = HttpClientConfig()

def get_http_client(config: HttpClientConfig | None = None) -> httpx.AsyncClient:
    """
    Return the shared AsyncClient. Creates it on first call.
    In tests, call close_http_client() in teardown to reset state.
    """
    global _client, _config
    if config:
        _config = config
    if _client is None or _client.is_closed:
        _client = httpx.AsyncClient(
            limits=httpx.Limits(
                max_keepalive_connections=_config.max_keepalive_connections,
                max_connections=_config.max_connections,
            ),
            timeout=httpx.Timeout(_config.timeout_seconds),
            headers={
                "User-Agent": "Mozilla/5.0 (compatible; INGOT/0.1; +https://github.com/ingot)",
                "Accept": "text/html,application/json,*/*",
            },
            follow_redirects=True,
        )
    return _client

async def close_http_client() -> None:
    global _client
    if _client and not _client.is_closed:
        await _client.aclose()
    _client = None
```

**src/ingot/dispatcher.py:**

```python
"""
Async task dispatcher using asyncio.Queue.
Upgrade path to Redis isolated here — replace queue internals in v2 without touching agents.
"""
import asyncio
from dataclasses import dataclass, field
from typing import Callable, Any
from ingot.agents.exceptions import AgentError


@dataclass
class TaskResult:
    task_name: str
    success: bool
    result: Any = None
    error: Exception | None = None


class AsyncTaskDispatcher:
    """
    Worker pool over asyncio.Queue.
    Usage:
        dispatcher = AsyncTaskDispatcher(max_workers=3)
        dispatcher.enqueue("scout", scout_fn, deps=deps, batch=companies)
        results = await dispatcher.run_all()
    """

    def __init__(self, max_workers: int = 3):
        self.max_workers = max_workers
        self._queue: asyncio.Queue = asyncio.Queue()
        self._results: list[TaskResult] = []

    def enqueue(self, task_name: str, coro_fn: Callable, **kwargs) -> None:
        """Add a task to the queue. coro_fn is an async callable."""
        self._queue.put_nowait((task_name, coro_fn, kwargs))

    async def run_all(self) -> list[TaskResult]:
        """
        Drain the queue using max_workers concurrent workers.
        Returns all TaskResults (success and failure) in completion order.
        """
        workers = [self._worker() for _ in range(self.max_workers)]
        await asyncio.gather(*workers)
        return self._results

    async def _worker(self) -> None:
        while True:
            try:
                task_name, coro_fn, kwargs = self._queue.get_nowait()
            except asyncio.QueueEmpty:
                return
            try:
                result = await coro_fn(**kwargs)
                self._results.append(TaskResult(task_name=task_name, success=True, result=result))
            except Exception as e:
                self._results.append(TaskResult(task_name=task_name, success=False, error=e))
            finally:
                self._queue.task_done()
```

Also create stubs for aiosmtplib and aioimaplib to validate the dependency tree (INFRA-19, INFRA-20):
```python
# Add to src/ingot/__init__.py or a stubs module:
# These are imported here only to validate they're installed.
# Actual use is in Phase 3.
try:
    import aiosmtplib  # noqa: F401
    import aioimaplib  # noqa: F401
except ImportError as e:
    import warnings
    warnings.warn(f"Phase 3 dependency not installed: {e}. Run: pip install aiosmtplib aioimaplib")
```

Add the import validation block to `src/ingot/__init__.py`.
  </action>
  <verify>
    <automated>python -c "
import asyncio
from ingot.agents.base import AgentDeps, AgentBase
from ingot.agents.registry import AGENT_REGISTRY, register_agent, get_agent, list_agents
from ingot.http_client import get_http_client, close_http_client
from ingot.dispatcher import AsyncTaskDispatcher, TaskResult

# Registry test
register_agent('test_agent', object())
assert 'test_agent' in list_agents()
assert get_agent('test_agent') is not None
try:
    get_agent('nonexistent')
    assert False
except KeyError:
    pass
print('Registry OK')

# HTTP client singleton test
client1 = get_http_client()
client2 = get_http_client()
assert client1 is client2, 'HTTP client should be singleton'
assert client1.limits.max_connections == 10
print('HTTP client OK')

# Dispatcher test
async def test_dispatcher():
    dispatcher = AsyncTaskDispatcher(max_workers=3)
    results_check = []

    async def sample_task(name):
        results_check.append(name)
        return f'done-{name}'

    for i in range(5):
        dispatcher.enqueue(f'task_{i}', sample_task, name=f'task_{i}')

    results = await dispatcher.run_all()
    assert len(results) == 5
    assert all(r.success for r in results)
    print('Dispatcher OK')

asyncio.run(test_dispatcher())

# Phase 3 deps importable
import aiosmtplib, aioimaplib
print('Phase 3 deps importable OK')
print('All base/registry/http/dispatcher tests passed')
"
    </automated>
  </verify>
  <done>
    AgentDeps dataclass exists with correct fields. AGENT_REGISTRY registers and retrieves agents. HTTP client is a singleton with correct pool limits. AsyncTaskDispatcher drains queue correctly with concurrent workers. aiosmtplib and aioimaplib import without error.
  </done>
</task>

<task type="auto">
  <name>Task 2: All 7 PydanticAI agent shells and Orchestrator skeleton</name>
  <files>
    src/ingot/agents/__init__.py
    src/ingot/agents/orchestrator.py
    src/ingot/agents/scout.py
    src/ingot/agents/research.py
    src/ingot/agents/matcher.py
    src/ingot/agents/writer.py
    src/ingot/agents/outreach.py
    src/ingot/agents/analyst.py
  </files>
  <action>
**Before writing any agent code:** Check the actual PydanticAI v1.x `Agent` constructor using:
```bash
python -c "import pydantic_ai; help(pydantic_ai.Agent.__init__)"
```
Use whatever the installed version actually accepts. Do NOT guess based on training data — the RESEARCH.md explicitly flags v0.x vs v1.x API as a pitfall (Pitfall 4).

**Pattern for all 6 non-Orchestrator agents** (Scout, Research, Matcher, Writer, Outreach, Analyst):

```python
# src/ingot/agents/scout.py
from dataclasses import dataclass
from pydantic_ai import Agent, RunContext
from ingot.agents.base import AgentDeps
from ingot.agents.registry import register_agent

# PydanticAI v1.x: use the correct parameter name from inspect output
# Common v1.x API: Agent(model_name, deps_type=AgentDeps)
scout_agent = Agent(
    "ollama/llama3.1",  # Overridden at runtime from config
    deps_type=AgentDeps,
    system_prompt="You are a lead discovery agent for INGOT. "
                  "You discover and qualify startup leads for personalized outreach.",
)

register_agent("scout", scout_agent)
```

Create the same shell for: `research.py`, `matcher.py`, `writer.py`, `outreach.py`, `analyst.py` — each with an appropriate one-sentence system_prompt describing the agent's role.

**AGENT-05 enforcement:** No agent file imports from any other agent file. Each agent only imports from `ingot.agents.base`, `ingot.agents.registry`, `ingot.agents.exceptions`, `ingot.llm`, `ingot.db`, and stdlib/third-party. Add a comment at the top of each agent file:
```python
# AGENT-05: This module MUST NOT import from other agent modules.
# Only Orchestrator coordinates between agents.
```

**src/ingot/agents/orchestrator.py** — AGENT-07: keep under 250 lines. This is a skeleton for Phase 1; actual routing logic is added in Phase 2 (AGENT-04).

```python
"""
Orchestrator — campaign coordinator and sole agent router.
AGENT-07: This file must stay under 250 lines. Domain logic belongs in agents.
AGENT-05: Orchestrator is the ONLY module that imports multiple agents.
"""
from ingot.agents.base import AgentDeps
from ingot.agents.registry import get_agent, list_agents
from ingot.agents.exceptions import AgentError
from ingot.logging_config import get_logger

logger = get_logger("ingot.orchestrator")

class Orchestrator:
    """
    Routes tasks to agents by name. Maintains campaign state (Phase 2).
    In Phase 1 this is a skeleton: run() delegates to the named agent.
    """

    def __init__(self, deps: AgentDeps):
        self.deps = deps

    async def run(self, agent_name: str, **kwargs) -> dict:
        """Dispatch a task to the named agent and return its result."""
        logger.info(f"[Orchestrator] Dispatching to {agent_name}")
        agent = get_agent(agent_name)
        try:
            result = await agent.run(str(kwargs), deps=self.deps)
            return {"agent": agent_name, "success": True, "output": result.output}
        except Exception as e:
            raise AgentError("Orchestrator", f"Agent '{agent_name}' failed: {e}", cause=e) from e

    def list_available_agents(self) -> list[str]:
        return list_agents()
```

**src/ingot/agents/__init__.py** — import all agent modules to trigger `register_agent()` calls. This ensures all agents are registered when `from ingot.agents import *` is executed:
```python
# Import all agents to populate AGENT_REGISTRY
from ingot.agents import (  # noqa: F401
    orchestrator, scout, research, matcher, writer, outreach, analyst
)
from ingot.agents.registry import AGENT_REGISTRY, get_agent, list_agents
from ingot.agents.base import AgentDeps, AgentBase
from ingot.agents.exceptions import (
    IngotError, LLMError, LLMValidationError, DBError,
    ConfigError, ValidationError, AgentError
)
```

**Line count check for Orchestrator:** After writing, run `wc -l src/ingot/agents/orchestrator.py` and confirm it is under 250 lines.
  </action>
  <verify>
    <automated>python -c "
import asyncio
from unittest.mock import patch, MagicMock

# Verify all 7 agents import without error
from ingot.agents import orchestrator, scout, research, matcher, writer, outreach, analyst
from ingot.agents.registry import list_agents, AGENT_REGISTRY
from ingot.agents.base import AgentDeps

# All 7 agents registered
agents = list_agents()
print('Registered agents:', agents)
expected = {'orchestrator', 'scout', 'research', 'matcher', 'writer', 'outreach', 'analyst'}
# Orchestrator may or may not be in registry (it's a class, not a PydanticAI agent)
# At minimum the 6 non-orchestrator agents should be registered
for name in ['scout', 'research', 'matcher', 'writer', 'outreach', 'analyst']:
    assert name in AGENT_REGISTRY, f'{name} not in registry'
print('All 6 agent shells registered OK')

# Check import boundaries — no agent imports another agent (except orchestrator)
import ast, pathlib
agent_modules = ['scout', 'research', 'matcher', 'writer', 'outreach', 'analyst']
for module_name in agent_modules:
    path = pathlib.Path(f'src/ingot/agents/{module_name}.py')
    tree = ast.parse(path.read_text())
    for node in ast.walk(tree):
        if isinstance(node, ast.ImportFrom):
            if node.module and 'ingot.agents.' in node.module:
                imported = node.module.replace('ingot.agents.', '')
                assert imported not in agent_modules, \
                    f'{module_name}.py imports from {node.module} — AGENT-05 violation'
print('AGENT-05 import boundary check passed')

# Orchestrator line count
with open('src/ingot/agents/orchestrator.py') as f:
    lines = sum(1 for _ in f)
assert lines <= 250, f'Orchestrator is {lines} lines, exceeds 250 limit (AGENT-07)'
print(f'Orchestrator line count: {lines} (under 250 limit OK)')

print('All agent framework tests passed')
"
    </automated>
  </verify>
  <done>
    All 7 agent shells import without error using PydanticAI v1.x API. AGENT_REGISTRY contains all 6 non-Orchestrator agents after import. No agent file (except orchestrator.py) imports from another agent module. Orchestrator is under 250 lines. AsyncTaskDispatcher routes tasks correctly.
  </done>
</task>

</tasks>

<verification>
Run after all tasks complete:

```bash
# Full agent framework verification
python -c "
from ingot.agents import *
from ingot.agents.registry import list_agents
from ingot.http_client import get_http_client
from ingot.dispatcher import AsyncTaskDispatcher
import asyncio

print('Registered agents:', list_agents())

# HTTP client singleton
c1 = get_http_client()
c2 = get_http_client()
assert c1 is c2

# Dispatcher with 3 concurrent workers
async def test_dispatch():
    d = AsyncTaskDispatcher(max_workers=3)
    async def noop(n): return n
    for i in range(6):
        d.enqueue(f't{i}', noop, n=i)
    results = await d.run_all()
    assert len(results) == 6
    print('Dispatch 6 tasks via 3 workers: OK')

asyncio.run(test_dispatch())

# Verify aiosmtplib / aioimaplib stubs importable
import aiosmtplib, aioimaplib
print('Phase 3 stubs OK')
print('Agent framework verification complete')
"

# Orchestrator line count
wc -l src/ingot/agents/orchestrator.py
```
</verification>

<success_criteria>
- All 7 agents are importable and registered in AGENT_REGISTRY
- PydanticAI v1.x API is used correctly (executor must verify by checking installed version)
- No cross-agent imports (AGENT-05) — verified by AST scan
- Orchestrator is under 250 lines (AGENT-07)
- AgentDeps dataclass carries llm_client, session, http_client — never global state (AGENT-06)
- AsyncTaskDispatcher with asyncio.Queue handles concurrent tasks without dropping any (INFRA-17)
- Shared httpx.AsyncClient has connection pooling with max_connections=10 (INFRA-18)
- aiosmtplib and aioimaplib import without error (INFRA-19, INFRA-20)
- All INFRA-17 through INFRA-20 and AGENT-01 through AGENT-09 requirements are addressed
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-core-infrastructure/01-04-SUMMARY.md` with:
- Confirmed PydanticAI version and exact Agent constructor parameter names used
- Agent registration pattern (how agents self-register)
- AgentDeps field list (for Plan 01-05 fixture setup)
- Orchestrator line count
- Any PydanticAI v1.x API discoveries that deviate from RESEARCH.md examples
</output>
