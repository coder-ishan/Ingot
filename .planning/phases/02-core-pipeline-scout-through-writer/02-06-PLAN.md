---
phase: 02-core-pipeline-scout-through-writer
plan: 06
type: execute
wave: 4
depends_on:
  - "02-05"
  - "02-04"
  - "02-03"
  - "02-02"
  - "02-01"
autonomous: false
files_modified:
  - src/ingot/agents/orchestrator.py
  - src/ingot/review/queue.py
  - src/ingot/review/__init__.py
  - src/ingot/cli/pipeline.py
  - src/ingot/cli/setup.py
requirements:
  - AGENT-04

must_haves:
  truths:
    - "Orchestrator stays under 250 lines — all domain logic delegates to agent modules (AGENT-07)"
    - "Pipeline checkpoints via Lead.status: on resume, the Orchestrator queries leads by status and skips already-completed stages (no duplicate research or duplicate drafts)"
    - "Review queue shows a list-view table first (lead name, company, match score, status), then deep-dives one lead at a time with the full draft set"
    - "Inline editing uses Rich console.input() — no external editor dependency"
    - "Regeneration is silent re-run (same MCQ answers + different seed); no additional prompts before regenerating"
    - "Reject/regenerate with 'different angle' flag re-triggers MCQ"
    - "The orchestrator handles the full pipeline: Scout -> Phase1Research -> ApprovalGate -> Phase2Research -> Matcher -> Writer -> ReviewQueue"
    - "CLI command 'ingot run pipeline' triggers the full orchestrated run"
  artifacts:
    - path: "src/ingot/agents/orchestrator.py"
      provides: "OrchestratorDeps dataclass, run_pipeline() async function — full pipeline coordination under 250 lines"
      exports: ["OrchestratorDeps", "run_pipeline"]
    - path: "src/ingot/review/queue.py"
      provides: "show_lead_list() function (Rich Table list view), show_draft_deepdive() function (Rich Panel deep-dive), run_review_queue() async function"
      exports: ["show_lead_list", "show_draft_deepdive", "run_review_queue"]
    - path: "src/ingot/cli/pipeline.py"
      provides: "Typer CLI command 'ingot run pipeline' that invokes run_pipeline()"
      exports: ["pipeline_app"]
  key_links:
    - from: "src/ingot/agents/orchestrator.py"
      to: "src/ingot/agents/scout.py"
      via: "run_pipeline() calls scout_run(ScoutDeps(...))"
      pattern: "scout_run"
    - from: "src/ingot/agents/orchestrator.py"
      to: "src/ingot/agents/research.py"
      via: "run_pipeline() calls research_phase1(), run_approval_gate(), research_phase2(), update_lead_status()"
      pattern: "research_phase1|research_phase2"
    - from: "src/ingot/agents/orchestrator.py"
      to: "src/ingot/agents/matcher.py"
      via: "run_pipeline() calls run_matcher(MatcherDeps(...))"
      pattern: "run_matcher"
    - from: "src/ingot/agents/orchestrator.py"
      to: "src/ingot/agents/writer.py"
      via: "run_pipeline() calls run_writer(WriterDeps(...))"
      pattern: "run_writer"
    - from: "src/ingot/agents/orchestrator.py"
      to: "src/ingot/review/queue.py"
      via: "run_pipeline() calls run_review_queue() after all drafts produced"
      pattern: "run_review_queue"
    - from: "src/ingot/review/queue.py"
      to: "src/ingot/agents/writer.py"
      via: "Regenerate action calls run_writer(deps, retrigger_mcq=user_wants_different_angle)"
      pattern: "run_writer.*retrigger_mcq"
---

<objective>
Wire the full pipeline via the Orchestrator, implement the Rich CLI review queue, and expose 'ingot run pipeline' CLI command.

Purpose: The Orchestrator is the only coordinator — no agent imports another agent. It sequences Scout -> Phase1Research -> ApprovalGate -> Phase2Research -> Matcher -> Writer -> ReviewQueue. Checkpoint/resume is built on Lead.status so a crash mid-run can resume without duplicating work. The review queue (approve/edit/reject/regenerate) is the v1 done condition UX.
Output: `orchestrator.py` (pipeline coordinator, <250 lines), `review/queue.py` (Rich list-view + deep-dive), `cli/pipeline.py` (Typer command).
</objective>

<execution_context>
@/Users/ishansingh/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ishansingh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@.planning/phases/02-core-pipeline-scout-through-writer/02-RESEARCH.md
@.planning/phases/02-core-pipeline-scout-through-writer/02-CONTEXT.md
@src/ingot/config/manager.py
@src/ingot/db/models.py
@.planning/phases/02-core-pipeline-scout-through-writer/02-03-SUMMARY.md
@.planning/phases/02-core-pipeline-scout-through-writer/02-04-SUMMARY.md
@.planning/phases/02-core-pipeline-scout-through-writer/02-05-SUMMARY.md

<interfaces>
<!-- Agent function signatures for Orchestrator to call -->
From src/ingot/agents/scout.py:
```python
async def scout_run(deps: ScoutDeps) -> list[Lead]: ...
```

From src/ingot/agents/research.py:
```python
async def research_phase1(deps: ResearchDeps) -> IntelBriefPhase1 | None: ...
def run_approval_gate(lead: Lead, phase1: IntelBriefPhase1) -> str: ...  # "accept"|"reject"|"defer"
async def research_phase2(deps: ResearchDeps) -> IntelBriefFull: ...
async def update_lead_status(lead: Lead, new_status: LeadStatus, session: AsyncSession) -> None: ...
```

From src/ingot/agents/matcher.py:
```python
async def run_matcher(deps: MatcherDeps) -> MatchResult: ...
```

From src/ingot/agents/writer.py:
```python
async def run_mcq(deps: WriterDeps) -> MCQAnswers: ...
async def run_writer(deps: WriterDeps, retrigger_mcq: bool = False) -> EmailDraft: ...
```

From src/ingot/db/models.py:
```python
class LeadStatus(str, Enum):
    discovered = "discovered"
    researching = "researching"
    approved = "approved"
    matched = "matched"
    drafted = "drafted"
    rejected = "rejected"
    # (sent, replied added in Phase 3)

class Email(SQLModel, table=True):
    id: int | None; subject_a: str; subject_b: str; body: str
    tone_adapted_for: str; status: EmailStatus; lead_id: int | None

class FollowUp(SQLModel, table=True):
    id: int | None; parent_email_id: int | None; scheduled_for_day: int; body: str; status: FollowUpStatus
```

Review Queue UX (from 02-CONTEXT.md LOCKED DECISIONS):
- Entry: list-view table (lead name, company, match score, status: pending/approved/rejected)
- Deep-dive: one lead at a time — full draft set (subject A/B, body, Day 3, Day 7)
- Inline edit: Rich console.input() — no external editor
- Regenerate: silent re-run, same MCQ answers + different seed; no extra prompts
- Reject/different angle: re-triggers MCQ
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Orchestrator and review queue</name>
  <files>
    src/ingot/agents/orchestrator.py
    src/ingot/review/__init__.py
    src/ingot/review/queue.py
  </files>
  <action>
Build the Orchestrator (pipeline coordinator, strict <250 lines) and the Rich CLI review queue.

**src/ingot/review/queue.py** — Review queue UI:

```python
"""
Rich CLI Review Queue — list-view + deep-dive UX.

LOCKED DECISIONS (02-CONTEXT.md):
- Entry: list-view table (lead name, company, match score, status)
- Deep-dive: one lead at a time with full draft set
- Inline edit: Rich console.input() — NO external editor (Prompt pitfall: do not use Live context)
- Regenerate: silent re-run, same MCQ answers; no extra prompts
- Reject/different angle: retrigger_mcq=True passed to run_writer()

PITFALL (from 02-RESEARCH.md Pitfall 5):
  Do NOT use Rich.Live display during prompts. Live captures stdout and conflicts
  with console.input(). Use sequential console.print() + Prompt.ask() only.
"""
import json
from dataclasses import dataclass

from rich.console import Console
from rich.panel import Panel
from rich.prompt import Prompt
from rich.table import Table
from sqlalchemy.ext.asyncio import AsyncSession
from sqlmodel import select

from ingot.db.models import Lead, Email, FollowUp, LeadStatus, EmailStatus
from ingot.agents.writer import WriterDeps, run_writer

console = Console()


def show_lead_list(leads: list[Lead], emails: dict[int, Email]) -> str | None:
    """
    LOCKED DECISION: Show list-view table first.
    Returns the lead number selected (1-indexed str) or None to quit.
    """
    table = Table(
        title="Email Review Queue",
        show_header=True,
        header_style="bold cyan",
        border_style="dim",
    )
    table.add_column("#", style="dim", width=4, justify="right")
    table.add_column("Name", style="white", min_width=15)
    table.add_column("Company", style="magenta", min_width=15)
    table.add_column("Score", justify="right", style="yellow", width=7)
    table.add_column("Status", width=10)

    for i, lead in enumerate(leads, 1):
        email = emails.get(lead.id)
        email_status = email.status if email else "no draft"
        status_style = {
            "drafted": "yellow",
            "approved": "green",
            "rejected": "red",
            "no draft": "dim",
        }.get(str(email_status), "white")
        score_str = f"{lead.initial_score * 100:.0f}" if lead.initial_score else "-"
        table.add_row(
            str(i),
            lead.person_name or "(TBD)",
            lead.company_name,
            score_str,
            f"[{status_style}]{email_status}[/{status_style}]",
        )

    console.print()
    console.print(table)
    choice = Prompt.ask(
        "Enter lead number to review, or [bold]q[/bold] to quit",
        default="q",
    )
    return None if choice.strip().lower() == "q" else choice.strip()


def show_draft_deepdive(lead: Lead, email: Email, followups: list[FollowUp]) -> str:
    """
    LOCKED DECISION: Deep-dive one lead at a time with full draft set.
    Returns action: "approve" | "edit" | "reject" | "regenerate"
    """
    fu_day3 = next((f for f in followups if f.scheduled_for_day == 3), None)
    fu_day7 = next((f for f in followups if f.scheduled_for_day == 7), None)

    content = (
        f"[bold]Subject A:[/] {email.subject_a}\n"
        f"[bold]Subject B:[/] {email.subject_b}\n\n"
        f"[bold]Body:[/]\n{email.body}\n"
    )
    if fu_day3:
        content += f"\n[dim]--- Day 3 Follow-up ---[/dim]\n{fu_day3.body}\n"
    if fu_day7:
        content += f"\n[dim]--- Day 7 Follow-up ---[/dim]\n{fu_day7.body}\n"

    console.print()
    console.print(Panel(
        content,
        title=f"[bold]{lead.person_name or 'Contact'} @ {lead.company_name}[/]",
        border_style="blue",
        expand=False,
    ))

    return Prompt.ask(
        "Action",
        choices=["approve", "edit", "reject", "regenerate"],
        default="approve",
    )


async def run_review_queue(
    leads: list[Lead],
    session: AsyncSession,
    writer_deps_factory,  # Callable[Lead] -> WriterDeps (provided by Orchestrator)
) -> dict[int, str]:
    """
    Run the full review queue loop.

    Returns dict mapping lead_id -> final action taken ("approved"/"rejected").

    PITFALL: Do NOT call console.input() inside a Rich.Live context.
    This function uses sequential print+prompt only (no Live display).
    """
    # Load emails for all leads
    emails: dict[int, Email] = {}
    for lead in leads:
        result = await session.exec(select(Email).where(Email.lead_id == lead.id))
        email = result.first()
        if email:
            emails[lead.id] = email

    outcomes: dict[int, str] = {}

    while True:
        # Show list view
        # Only show leads that have drafts and aren't yet decided
        pending_leads = [
            l for l in leads
            if l.id in emails and outcomes.get(l.id) not in ("approved", "rejected")
        ]
        if not pending_leads:
            console.print("\n[bold green]All leads reviewed.[/bold green]")
            break

        choice = show_lead_list(pending_leads, emails)
        if choice is None:
            break

        try:
            idx = int(choice) - 1
            if idx < 0 or idx >= len(pending_leads):
                console.print("[red]Invalid selection.[/red]")
                continue
            lead = pending_leads[idx]
        except ValueError:
            console.print("[red]Enter a number or 'q'.[/red]")
            continue

        email = emails.get(lead.id)
        if not email:
            console.print(f"[yellow]No draft found for {lead.company_name}[/yellow]")
            continue

        # Load follow-ups
        fu_result = await session.exec(
            select(FollowUp).where(FollowUp.parent_email_id == email.id)
        )
        followups = list(fu_result.all())

        action = show_draft_deepdive(lead, email, followups)

        if action == "approve":
            email.status = EmailStatus.approved
            session.add(email)
            await session.commit()
            outcomes[lead.id] = "approved"
            console.print(f"[green]Approved: {lead.company_name}[/green]")

        elif action == "edit":
            # LOCKED DECISION: Inline editing via console.input()
            console.print("[dim]Paste or type the revised email body. Press Enter twice when done.[/dim]")
            lines = []
            while True:
                line = console.input("")
                lines.append(line)
                if len(lines) >= 2 and lines[-1] == "" and lines[-2] == "":
                    break
            new_body = "\n".join(lines[:-2])  # Remove the two trailing empty lines
            if new_body.strip():
                email.body = new_body
                email.status = EmailStatus.approved
                session.add(email)
                await session.commit()
                emails[lead.id] = email
                outcomes[lead.id] = "approved"
                console.print(f"[green]Edited and approved: {lead.company_name}[/green]")

        elif action == "reject":
            email.status = EmailStatus.rejected
            lead.status = LeadStatus.rejected
            session.add(email)
            session.add(lead)
            await session.commit()
            outcomes[lead.id] = "rejected"
            console.print(f"[red]Rejected: {lead.company_name}[/red]")

        elif action == "regenerate":
            # LOCKED DECISION: Silent re-run, same MCQ answers + different seed
            # Ask if different angle wanted (triggers MCQ retrigger per WRITER-13)
            different_angle = Prompt.ask(
                "Different angle?",
                choices=["y", "n"],
                default="n",
            ) == "y"
            console.print(f"[yellow]Regenerating draft for {lead.company_name}...[/yellow]")
            try:
                writer_deps = writer_deps_factory(lead)
                await run_writer(writer_deps, retrigger_mcq=different_angle)
                # Reload email
                result = await session.exec(select(Email).where(Email.lead_id == lead.id))
                # Get the latest draft (highest id)
                new_emails = list(result.all())
                if new_emails:
                    emails[lead.id] = max(new_emails, key=lambda e: e.id or 0)
                console.print(f"[green]Regenerated: {lead.company_name}[/green]")
            except Exception as e:
                console.print(f"[red]Regeneration failed: {e}[/red]")

    return outcomes
```

Create `src/ingot/review/__init__.py` as empty package file.

**src/ingot/agents/orchestrator.py** — Pipeline coordinator:

```python
"""
Orchestrator — Pipeline coordinator. MUST stay under 250 lines (AGENT-07).

Responsibilities (AGENT-04):
  - Routes tasks to agents in sequence
  - Maintains campaign state via Lead.status (checkpoint/resume)
  - Handles approval gates (delegates to run_approval_gate())
  - Coordinates review queue (delegates to run_review_queue())

Checkpoint/Resume (Pattern 6 from 02-RESEARCH.md):
  Each stage queries leads by status. On resume after crash/interrupt,
  leads in completed statuses are skipped automatically.
  Status sequence: discovered -> researching -> approved/rejected -> matched -> drafted

AGENT-05: This is the ONLY module that imports from multiple agents.
No agent may import from another agent.
"""
from dataclasses import dataclass

import httpx
from rich.console import Console
from sqlalchemy.ext.asyncio import AsyncSession
from sqlmodel import select

from ingot.agents.matcher import MatcherDeps, run_matcher
from ingot.agents.research import ResearchDeps, research_phase1, research_phase2, run_approval_gate, update_lead_status
from ingot.agents.scout import ScoutDeps, scout_run
from ingot.agents.writer import WriterDeps, run_mcq, run_writer
from ingot.db.models import Lead, LeadStatus, IntelBrief, Match, Email
from ingot.models.schemas import UserProfile, IntelBriefFull, MatchResult
from ingot.review.queue import run_review_queue

console = Console()


@dataclass
class OrchestratorDeps:
    session: AsyncSession
    http_client: httpx.AsyncClient
    user_profile: UserProfile       # loaded from DB at startup
    user_skills: list[str]          # shortcut from user_profile.skills
    resume_text: str                # for scoring
    sender_name: str = ""
    sender_email: str = ""
    physical_address: str = ""      # CAN-SPAM requirement
    yc_batch: str | None = None     # optional batch filter


async def run_pipeline(deps: OrchestratorDeps) -> None:
    """
    Run the full INGOT pipeline end-to-end.

    Stage 1: Scout (discover leads)
    Stage 2: Phase 1 Research + Approval Gate (per lead)
    Stage 3: Phase 2 Research (approved leads only)
    Stage 4: Matcher (approved leads)
    Stage 5: Writer + MCQ (matched leads)
    Stage 6: Review Queue (drafted leads)

    CHECKPOINT/RESUME: Each stage queries by Lead.status.
    Interrupted runs resume from the last incomplete stage.
    """
    session = deps.session

    # ---- STAGE 1: Scout ----
    console.rule("[bold cyan]Stage 1: Scout — Discovering Leads[/bold cyan]")
    existing_discovered = await session.exec(
        select(Lead).where(Lead.status == LeadStatus.discovered)
    )
    if not existing_discovered.all():
        scout_deps = ScoutDeps(
            http_client=deps.http_client,
            session=session,
            user_skills=deps.user_skills,
            resume_text=deps.resume_text,
            batch=deps.yc_batch,
        )
        leads = await scout_run(scout_deps)
        console.print(f"[green]Discovered {len(leads)} leads[/green]")
    else:
        leads = list((await session.exec(select(Lead).where(Lead.status == LeadStatus.discovered))).all())
        console.print(f"[yellow]Resuming with {len(leads)} existing discovered leads[/yellow]")

    # ---- STAGE 2: Phase 1 Research + Approval Gate ----
    console.rule("[bold cyan]Stage 2: Phase 1 Research + Approval Gate[/bold cyan]")
    discovered_leads = list((await session.exec(
        select(Lead).where(Lead.status.in_([LeadStatus.discovered, LeadStatus.researching]))
    )).all())

    for lead in discovered_leads:
        try:
            research_deps = ResearchDeps(
                http_client=deps.http_client,
                session=session,
                lead=lead,
            )
            phase1 = await research_phase1(research_deps)
            if phase1 is None:
                continue

            action = run_approval_gate(lead, phase1)
            if action == "accept":
                await update_lead_status(lead, LeadStatus.approved, session)
                console.print(f"  [green]Accepted:[/green] {lead.company_name}")
            elif action == "reject":
                await update_lead_status(lead, LeadStatus.rejected, session)
                console.print(f"  [red]Rejected:[/red] {lead.company_name}")
            else:
                console.print(f"  [yellow]Deferred:[/yellow] {lead.company_name}")
        except Exception as e:
            console.print(f"  [red]Research Phase 1 failed for {lead.company_name}: {e}[/red]")

    # ---- STAGE 3: Phase 2 Research (approved only) ----
    console.rule("[bold cyan]Stage 3: Phase 2 Research[/bold cyan]")
    approved_leads = list((await session.exec(
        select(Lead).where(Lead.status == LeadStatus.approved)
    )).all())

    full_briefs: dict[int, IntelBriefFull] = {}
    for lead in approved_leads:
        try:
            research_deps = ResearchDeps(
                http_client=deps.http_client,
                session=session,
                lead=lead,
            )
            full_brief = await research_phase2(research_deps)
            full_briefs[lead.id] = full_brief
            console.print(f"  [green]Phase 2 complete:[/green] {lead.company_name}")
        except Exception as e:
            console.print(f"  [red]Research Phase 2 failed for {lead.company_name}: {e}[/red]")

    # ---- STAGE 4: Matcher ----
    console.rule("[bold cyan]Stage 4: Matcher[/bold cyan]")
    # Reload approved leads (some may now have Phase 2 complete)
    approved_leads = list((await session.exec(
        select(Lead).where(Lead.status == LeadStatus.approved)
    )).all())

    match_results: dict[int, MatchResult] = {}
    for lead in approved_leads:
        if lead.id not in full_briefs:
            continue
        try:
            brief_result = await session.exec(
                select(IntelBrief).where(IntelBrief.lead_id == lead.id)
            )
            brief_db = brief_result.first()
            if not brief_db:
                continue
            intel = full_briefs[lead.id]
            matcher_deps = MatcherDeps(
                user_profile=deps.user_profile,
                intel_brief=intel,
                match_result=None,
                lead=lead,
                session=session,
            )
            match_result = await run_matcher(matcher_deps)
            match_results[lead.id] = match_result
            console.print(f"  [green]Matched:[/green] {lead.company_name} (score={match_result.match_score:.0f})")
        except Exception as e:
            console.print(f"  [red]Matcher failed for {lead.company_name}: {e}[/red]")

    # ---- STAGE 5: Writer + MCQ ----
    console.rule("[bold cyan]Stage 5: Writer + MCQ[/bold cyan]")
    matched_leads = list((await session.exec(
        select(Lead).where(Lead.status == LeadStatus.matched)
    )).all())

    writer_deps_map: dict[int, WriterDeps] = {}
    for lead in matched_leads:
        if lead.id not in match_results and lead.id not in full_briefs:
            continue
        try:
            intel = full_briefs.get(lead.id)
            match_res = match_results.get(lead.id)
            if not intel or not match_res:
                continue
            writer_deps = WriterDeps(
                user_profile=deps.user_profile,
                intel_brief=intel,
                match_result=match_res,
                lead=lead,
                session=session,
                sender_name=deps.sender_name,
                sender_email=deps.sender_email,
                physical_address=deps.physical_address,
            )
            mcq_answers = await run_mcq(writer_deps)
            writer_deps.mcq_answers = mcq_answers
            await run_writer(writer_deps)
            writer_deps_map[lead.id] = writer_deps
            console.print(f"  [green]Drafted:[/green] {lead.company_name}")
        except Exception as e:
            console.print(f"  [red]Writer failed for {lead.company_name}: {e}[/red]")

    # ---- STAGE 6: Review Queue ----
    console.rule("[bold cyan]Stage 6: Review Queue[/bold cyan]")
    drafted_leads = list((await session.exec(
        select(Lead).where(Lead.status == LeadStatus.drafted)
    )).all())

    if not drafted_leads:
        console.print("[yellow]No drafted leads to review.[/yellow]")
        return

    def writer_deps_factory(lead: Lead) -> WriterDeps:
        return writer_deps_map.get(lead.id) or WriterDeps(
            user_profile=deps.user_profile,
            intel_brief=full_briefs.get(lead.id),
            match_result=match_results.get(lead.id),
            lead=lead,
            session=session,
            sender_name=deps.sender_name,
            sender_email=deps.sender_email,
            physical_address=deps.physical_address,
        )

    outcomes = await run_review_queue(drafted_leads, session, writer_deps_factory)
    approved_count = sum(1 for v in outcomes.values() if v == "approved")
    console.print(f"\n[bold green]Pipeline complete: {approved_count}/{len(outcomes)} leads approved[/bold green]")
```
  </action>
  <verify>
    <automated>python -c "
import inspect
from ingot.agents.orchestrator import OrchestratorDeps, run_pipeline
from ingot.review.queue import show_lead_list, show_draft_deepdive, run_review_queue

# Verify orchestrator line count
import ingot.agents.orchestrator as orch_mod
import inspect as ins
source = ins.getsource(orch_mod)
line_count = len(source.splitlines())
assert line_count <= 250, f'Orchestrator exceeds 250 lines: {line_count} lines'

# Verify run_pipeline is async
assert inspect.iscoroutinefunction(run_pipeline), 'run_pipeline must be async'

# Verify review queue functions exist
assert callable(show_lead_list)
assert callable(show_draft_deepdive)
assert inspect.iscoroutinefunction(run_review_queue)

print(f'Orchestrator line count: {line_count} (<= 250 OK)')
print('Orchestrator and review queue imports OK')
"
    </automated>
  </verify>
  <done>
    `orchestrator.py` is under 250 lines. `run_pipeline()` is async. All 6 pipeline stages are present. `show_lead_list()`, `show_draft_deepdive()`, and `run_review_queue()` all import from `ingot.review.queue`. Review queue uses `Prompt.ask()` not `Live` (no Live context during prompts).
  </done>
</task>

<task type="checkpoint:human-verify">
  <name>Task 2: CLI pipeline command and manual end-to-end smoke test</name>
  <files>
    src/ingot/cli/pipeline.py
    src/ingot/cli/setup.py
  </files>
  <action>
Add the `ingot run pipeline` CLI command and ensure it wires to `run_pipeline()`.

**src/ingot/cli/pipeline.py:**

```python
"""
CLI command group for pipeline execution.
Registered as 'ingot run' in src/ingot/cli/__init__.py.
"""
import asyncio
from pathlib import Path

import httpx
import typer
from rich.console import Console

from ingot.agents.orchestrator import OrchestratorDeps, run_pipeline
from ingot.config.manager import ConfigManager
from ingot.db.engine import get_session, init_db, create_engine
from ingot.db.models import UserProfile as UserProfileDB
from ingot.models.schemas import UserProfile

pipeline_app = typer.Typer(name="run", help="Run pipeline stages")
console = Console()


@pipeline_app.command("pipeline")
def run_pipeline_command(
    batch: str = typer.Option(None, "--batch", "-b", help="YC batch filter e.g. 'winter-2025'"),
):
    """Run the full INGOT pipeline: Scout -> Research -> Match -> Write -> Review."""
    asyncio.run(_run_async(batch=batch))


async def _run_async(batch: str | None = None):
    cm = ConfigManager()
    config = cm.load()

    # Load database
    engine = create_engine(f"sqlite+aiosqlite:///{cm.get_db_path()}")
    await init_db(engine)

    from sqlalchemy.orm import sessionmaker
    from sqlalchemy.ext.asyncio import AsyncSession as _AsyncSession
    Session = sessionmaker(engine, class_=_AsyncSession, expire_on_commit=False)

    async with Session() as session:
        # Load UserProfile from DB
        from sqlmodel import select
        result = await session.exec(select(UserProfileDB).limit(1))
        db_profile = result.first()

        if db_profile is None:
            console.print("[red]No UserProfile found. Run 'ingot config setup' first to upload your resume.[/red]")
            raise typer.Exit(1)

        user_profile = UserProfile(
            name=db_profile.name,
            headline=db_profile.headline,
            skills=db_profile.skills or [],
            experience=[e.get("entry", "") for e in (db_profile.experience or [])],
            education=[e.get("entry", "") for e in (db_profile.education or [])],
            projects=[p.get("entry", "") for p in (db_profile.projects or [])],
            github_url=db_profile.github_url or None,
            linkedin_url=db_profile.linkedin_url or None,
            resume_raw_text=db_profile.resume_raw_text or "",
        )

        async with httpx.AsyncClient() as http_client:
            orch_deps = OrchestratorDeps(
                session=session,
                http_client=http_client,
                user_profile=user_profile,
                user_skills=user_profile.skills,
                resume_text=user_profile.resume_raw_text,
                sender_name=db_profile.name,
                sender_email=config.smtp.username if config.smtp else "",
                physical_address=getattr(config, "mailing_address", ""),
                yc_batch=batch,
            )
            await run_pipeline(orch_deps)

    await engine.dispose()
```

**Update src/ingot/cli/setup.py** — Add `mailing_address` field collection to the existing setup wizard, so CAN-SPAM footer is populated. Find the section that saves SMTP credentials and add:

```python
# Add this field collection to the setup wizard flow (existing setup.py)
mailing_address = questionary.text(
    "Physical mailing address (required for CAN-SPAM compliance, e.g. '123 Main St, SF, CA 94105'):",
    default="",
).ask()
# Persist to config: config.mailing_address = mailing_address
```

The exact insertion point in setup.py depends on its current structure. Read the file and add after the SMTP section. The AppConfig schema may need a `mailing_address: str = ""` field added if not already present.

After implementing, run the CLI smoke test (MANUAL — requires human verification):

```bash
# Smoke test: verify CLI command registers correctly
ingot run --help
ingot run pipeline --help

# Expected output: shows batch option and command description
# Do NOT run the full pipeline (requires API keys and YC network access)
```
  </action>
  <verify>
    <automated>python -c "
# Verify CLI imports work
from ingot.cli.pipeline import pipeline_app, run_pipeline_command
import typer

# Verify the command is registered
commands = [c.name for c in pipeline_app.registered_commands]
assert 'pipeline' in commands, f'pipeline command not registered: {commands}'
print(f'CLI commands registered: {commands}')
print('CLI pipeline import OK')
"
    </automated>
  </verify>
  <done>
    `ingot run --help` shows the pipeline subcommand. `ingot run pipeline --help` shows the `--batch` option. The setup wizard now prompts for `mailing_address`. Orchestrator is under 250 lines. Review queue shows list-view table before deep-dive.
  </done>
</task>

</tasks>

<verification>
Run after all tasks complete:

```bash
# Line count check
python -c "
import ingot.agents.orchestrator as m
import inspect
lines = len(inspect.getsource(m).splitlines())
print(f'Orchestrator lines: {lines}')
assert lines <= 250, f'FAIL: {lines} > 250 lines'
print('PASS: under 250 lines')
"

# CLI registration check
python -c "
from ingot.cli.pipeline import pipeline_app
cmds = [c.name for c in pipeline_app.registered_commands]
assert 'pipeline' in cmds
print(f'CLI commands: {cmds}')
"

# Full import chain verification
python -c "
from ingot.agents.orchestrator import OrchestratorDeps, run_pipeline
from ingot.review.queue import run_review_queue, show_lead_list, show_draft_deepdive
from ingot.cli.pipeline import pipeline_app
print('Full import chain OK')
"
```
</verification>

<success_criteria>
- `orchestrator.py` is under 250 lines (AGENT-07 enforced)
- `run_pipeline()` implements all 6 stages with checkpoint/resume via Lead.status queries
- Review queue: list-view table first, deep-dive second, no Rich.Live context during prompts
- Inline edit uses `console.input()` (not external editor)
- Regenerate passes `retrigger_mcq=different_angle` to `run_writer()`
- `ingot run pipeline` command is registered in CLI and shows `--batch` option
- Setup wizard collects `mailing_address` for CAN-SPAM footer
- AGENT-04 requirement addressed
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-pipeline-scout-through-writer/02-06-SUMMARY.md` with:
- Orchestrator final line count (must be <= 250)
- Stage sequence confirmed: Scout -> P1Research -> Gate -> P2Research -> Matcher -> Writer -> ReviewQueue
- Lead.status transitions used for checkpoint/resume
- Review queue action map: approve=approved, edit=approved (with changes), reject=rejected, regenerate=re-run_writer
- CLI command: `ingot run pipeline [--batch BATCH]`
- mailing_address config field location (AppConfig field name)
</output>
